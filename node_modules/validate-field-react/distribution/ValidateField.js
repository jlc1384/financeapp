'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Extract Validation Rules from props.
 * When props are provided to the component a whitelist
 * of validation rules is used to extract the appropriate
 * keys from the props object. Each rule has a function, which
 * validates the input against any parameters and the value entered/selected
 * by the user.
 *
 * @param   {object}  props  Props from the component
 *
 * @return  {array}          An array of objects used internally
 */
var extractValidaitonRules = function extractValidaitonRules(props) {
  var rulesWhitelist = [{
    name: 'isRequired',
    func: function func(v) {
      return v.length === 0;
    }
  }, {
    name: 'isNumeric',
    func: function func(v) {
      return isNaN(v);
    }
  }, {
    name: 'isNotNumeric',
    func: function func(v) {
      return !isNaN(v);
    }
  }, {
    name: 'minLength',
    func: function func(v, l) {
      return v.length < l ? l : false;
    }
  }, {
    name: 'maxLength',
    func: function func(v, l) {
      return v.length > l ? l : false;
    }
  }, {
    name: 'isEmail',
    func: function func(v) {
      var emailRegex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
      return !emailRegex.test(v);
    }
  }];

  return rulesWhitelist.filter(function (i) {
    return props[i.name];
  }).map(function (rule) {
    return {
      name: rule.name,
      value: props[rule.name],
      func: rule.func
    };
  });
};

/**
 * Prop Types Validation
 *
 * @type object
 */
var propTypes = {
  isRequired: _react.PropTypes.bool,
  isNumeric: _react.PropTypes.bool,
  isNotNumeric: _react.PropTypes.bool,
  minLength: _react.PropTypes.number,
  maxLength: _react.PropTypes.number,
  component: _react.PropTypes.element,
  onChange: _react.PropTypes.func,
  name: _react.PropTypes.string.isRequired
};

/**
 * Default Props
 *
 * @type  object
 */
var defaultProps = {
  isRequired: false
};

var ValidateField = function (_Component) {
  _inherits(ValidateField, _Component);

  function ValidateField(props) {
    _classCallCheck(this, ValidateField);

    var _this = _possibleConstructorReturn(this, (ValidateField.__proto__ || Object.getPrototypeOf(ValidateField)).call(this, props));

    _this.state = {
      errorMessage: false, // message to show the user
      dirty: false // whether a field has been validated
    };
    _this.validate = _this.validate.bind(_this);
    return _this;
  }

  /**
   * Render a validation error message
   *
   * @param   {string}  message  Validation message from props
   *
   * @return  {element}
   */


  _createClass(ValidateField, [{
    key: 'renderErrorMessage',
    value: function renderErrorMessage(message) {
      var component = this.props.component;

      if (component) {
        return _react2.default.cloneElement(component, {
          message: message
        });
      }

      return _react2.default.createElement(
        'p',
        { className: 'error' },
        message
      );
    }

    /**
     * Validate the input or selection and set state with any validation errors.
     * See @cloneFieldsWithProps for usage
     *
     * @param   {object}  e  An event such as keydown
     *
     * @return  {void}
     */

  }, {
    key: 'validate',
    value: function validate(e) {
      var validationErrors = ValidateField.getValidationErrors(this.props, e.target.value);

      // when there is at least one validation error, render the first one
      if (ValidateField.hasError(validationErrors)) {
        return this.setState({
          dirty: true,
          errorMessage: validationErrors[0]
        });
      }

      // revert back to initial state
      this.setState({
        errorMessage: false,
        dirty: false
      });
    }

    /**
     * Clone form fields with extra props to handle browser events
     *
     * @param   {node|array}  children  this.props.children
     * @param   {object}      state     A slice of the current state
     *
     * @return  {array}
     */

  }, {
    key: 'cloneFieldsWithProps',
    value: function cloneFieldsWithProps(children, state) {
      var _this2 = this;

      return _react2.default.Children.map(children, function (child) {
        if (child.type === 'input' || child.type === 'textarea') {
          return _react2.default.cloneElement(child, {
            onChange: state.dirty ? function (e) {
              if (_this2.props.onChange) {
                _this2.props.onChange(e.target.value, _this2.props.name);
              }
              return _this2.validate(e);
            } : function (e) {
              return _this2.props.onChange(e.target.value, _this2.props.name);
            },
            onBlur: _this2.validate
          });
        }

        return child;
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _state = this.state,
          errorMessage = _state.errorMessage,
          dirty = _state.dirty;

      var clonedChildren = this.cloneFieldsWithProps(this.props.children, { dirty: dirty });

      return _react2.default.createElement(
        'span',
        null,
        clonedChildren,
        errorMessage && this.renderErrorMessage(errorMessage)
      );
    }
  }]);

  return ValidateField;
}(_react.Component);

exports.default = ValidateField;


ValidateField.propTypes = propTypes;

ValidateField.defaultProps = defaultProps;

ValidateField.getValidationErrors = function (props, value) {
  var rules = extractValidaitonRules(props);
  // check that the resulting value is equal to value provided in props
  return rules.filter(function (rule) {
    return rule.func(value, rule.value) === rule.value;
  })
  // filter out any rules that don't have a message
  .filter(function (rule) {
    return props.message[rule.name];
  }).map(function (rule) {
    return props.message[rule.name];
  });
};

ValidateField.hasError = function (errors) {
  return errors.length > 0;
};